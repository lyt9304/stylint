'use strict'

/**
 * @description runs tests according to config ( or all if strict is true )
 * @return {Function | undefined} undefined if just calling the method, function is linting over
 */
var astlint = function(ast) {

  var checks = Object.getPrototypeOf( this ).nodeLintMethods
  var maxErrs = typeof this.config.maxErrors === 'number' ? this.config.maxErrors : false
  var maxWarnings = typeof this.config.maxWarnings === 'number' ? this.config.maxWarnings : false

  function _checkNode(node) {
    if ( node.__type === "Root" ) { return }

    var method = ''
    for ( method in checks ) {
      if ( checks.hasOwnProperty( method ) ) {
        if ( this.config[method] ) {
          //console.log(method)
          // save config rule name for use in reporters
          this.cache.rule = method
          // state.conf === 'always' || 'never' || etc
          this.state.conf = this.config[method].expect || this.config[method]
          // state.severity === 'error' || 'warning'
          this.state.severity = this.config[method].error ? 'Error' : 'Warning'
          // run the actual check against the line
          var lineno = this.cache.lineNo = node['lineno']
          var line = this.cache.origLine = this.cache.origLines[lineno-1]

          checks[method].call( this, node, line)

          if ( maxErrs &&
            this.cache.errs.length > this.config.maxErrors ) {
            return this.reporter( '', 'done', 'kill' )
          }
          if ( maxWarnings &&
            this.cache.warnings.length > this.config.maxWarnings ) {
            return this.reporter( '', 'done', 'kill' )
          }
        }
      }
    }
  }

  var queue = []
  var now = null
  queue.push(ast)

  // BFS traversal ast
  while(queue.length>0){
    var now = queue.shift()

    _checkNode.call(this, now)

    if(now.nodes){
      for(var i= 0;i<now.nodes.length;i++){
        queue.push(now.nodes[i])
      }
    }

    if(now.block){
      queue.push(now.block)
    }
  }
}

module.exports = astlint

